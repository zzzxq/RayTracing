sh build_and_run

2、光追项目整理

1、光追的原理
从摄像机出发，连向屏幕上的每个像素，作为一条光线，然后判断场景中的物体是否和光线相交，且可经过多次反射、折射来计算该像素的最终颜色。 
为了引入抗锯齿效果，在一个像素内进行多次采样，将结果平均

2、空间加速结构(BVH，aabb)
aabb包围盒，六个相对的面，使用时使用两个vec3向量表示，在判断相交时分别求出t进入xyz的最大时刻以及离开xyz的最小时刻，只需要保证t是大于0，即物体在光线前面，且进入的时间小于离开的时间即可。
bvh结构，按照物体进行划分，优点是不会出现多个物体在一个空间内的情况，比较适用于动态场景。场景构建的时间复杂度是nlogn
划分步骤：
1、从根节点开始划分，体现多态，里面用两个基类指针指向左右节点，可以是bvh_node, 或者是叶子结点的 sphere
2、按照xyz轴中的长轴进行划分，一分为二，分别求出每个节点的aabb包围盒
3、判断包围盒是否相交，如果相交继续判断左右子节点是否相交。

3、反射光、折射光公式推导
反射光 reflect
包括入射光线和法线

计算公式 
vec3 reflect(const vec3& v, const vec3& n) {
    return v - 2*dot(v,n)*n;
}

折射光线 refract
公式推导：在球系坐标上
1、T = A + B (出射光分成水平和垂直)                    
2、A = M *sin(θ2)   (M表示水平坐标)           
3、M = (I + C) / sin(θ1)   
4、B = -N * sqrt(q - A^2)

4、相机类的实现(fov，宽高比，推导lookat矩阵)
利用lookfrom和lookat计算出 view矩阵
//schemit正交
Direction = lookfrom - lookat
Right = cross(vup, Direction)
Up = cross(Direction, Right)

可得
lower_left = origin - half_width * u - half_height * v  - w 
此外，根据fov和aspect可得
h = 2 * tan(fov / 2)
w = h * apsect

先从lookfrom平移到原点
然后求出逆矩阵，从（1,0,0)(0,1,0,)(0,0,1)到Right，Up,Direction的矩阵，转置一下即可
5、纹理采样
纹理贴图采样，如何通过交点p和法向量求出该点的uv坐标

根据球面坐标，可得 u = φ / 2* PI, v = θ / pi
通过p点获取球体的uv坐标
根据球系坐标
x = cos(θ)cos(φ)
y = cos(θ)sin(φ)
z = sin(θ)

可得
φ = atan2(y, x)
θ = asin(z)

因为右手坐标系，所以要交换y和z轴
且计算出来的在
atan2()返回值范围为[ − π , π ] 
asin()的返回值范围为[ − π / 2 , π / 2 ]
所以要映射到 0-1之间

6、c++部分，智能指针以及多态的使用
多态部分
在材质，纹理，物体中使用到了多态和虚函数，使用同一个基类的指针指向不同的派生类，调用同一个函数，产生不同的效果
比如漫反射材质，镜面反射材质或者绝缘体材质，在获取交点散射方程不同，导致结果不同。
在纹理中，对于固定颜色纹理、噪音纹理、贴图纹理中在采样颜色时有不同的结果。
在物体中，对于球类物体，长方形，物体数组和bvh_node，都是继承自同一个类，在创建场景时，将物体都添加到物体数组中，使用基类指针指向，在判断相交时，先调用物体数组的hit函数，然后依次调用每个基类指针指向的物体相应的判断函数，该物体可以是bvh_node,sphere，rect等。

旋转和平移物体的特点：没有正真的移动物体，而是相反的移动了光线，在获取到交点后，将相应的交点正向移动即可。